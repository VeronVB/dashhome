<!--
  @file WidgetGrid.svelte
  @description GridStack.js wrapper for drag-and-drop widget layout
  @author Generated by OK Computer for Michal's Dashboard
  @date 2025-01-07
-->

<script lang="ts">
  import { onMount, onDestroy, createEventDispatcher } from 'svelte';
  import { GridStack } from 'gridstack';
  import type { GridStackOptions, GridStackWidget, GridStackEvent } from 'gridstack';
  import 'gridstack/dist/gridstack.min.css';
  import { apiClient } from '$lib/api/client';
  import { widgets, setWidgets, updateWidget } from '$lib/stores/widgets';
  import { browser } from '$app/environment';

  export let options: Partial<GridStackOptions> = {};
  export let editable = true;

  const dispatch = createEventDispatcher();

  let grid: GridStack | null = null;
  let gridElement: HTMLElement;
  let saveTimeout: NodeJS.Timeout;

  const defaultOptions: GridStackOptions = {
    cellHeight: 80,
    verticalMargin: 10,
    column: 12,
    minRow: 1,
    animate: true,
    float: true,
    disableOneColumnMode: true,
    resizable: {
      handles: 'se',
    },
    draggable: {
      handle: '.widget-drag-handle',
    },
    ...options,
  };

  const handleChange = (event: GridStackEvent, items: GridStackWidget[]) => {
    if (!browser || !grid) return;

    items.forEach(item => {
      const widget = $widgets.find(w => w.id === item.id);
      if (widget) {
        const updatedWidget = {
          ...widget,
          position: {
            x: item.x || 0,
            y: item.y || 0,
            w: item.w || 1,
            h: item.y || 1,
          },
        };
        updateWidget(widget.id, updatedWidget);
      }
    });

    // Debounce save to avoid excessive API calls
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(async () => {
      await saveWidgetLayout();
    }, 2000);

    dispatch('change', { items });
  };

  const handleAdded = (event: GridStackEvent, items: GridStackWidget[]) => {
    dispatch('added', { items });
  };

  const handleRemoved = (event: GridStackEvent, items: GridStackWidget[]) => {
    dispatch('removed', { items });
  };

  const saveWidgetLayout = async () => {
    try {
      // Save each widget's position
      for (const widget of $widgets) {
        await apiClient.updateWidget(widget.id, {
          position: widget.position,
        });
      }
    } catch (error) {
      console.error('Failed to save widget layout:', error);
    }
  };

  const loadWidgetLayout = async () => {
    try {
      const widgetList = await apiClient.getWidgets();
      setWidgets(widgetList);
      
      if (grid) {
        // Clear existing widgets
        grid.removeAll();
        
        // Add widgets to grid
        const gridItems = widgetList.map(widget => ({
          id: widget.id,
          x: widget.position.x,
          y: widget.position.y,
          w: widget.position.w,
          h: widget.position.h,
          content: '', // Content will be rendered by Svelte component
        }));
        
        grid.load(gridItems);
      }
    } catch (error) {
      console.error('Failed to load widget layout:', error);
    }
  };

  onMount(async () => {
    if (!browser || !gridElement) return;

    // Initialize GridStack
    grid = GridStack.init(defaultOptions, gridElement);

    // Set up event listeners
    grid.on('change', handleChange);
    grid.on('added', handleAdded);
    grid.on('removed', handleRemoved);

    // Load existing widgets
    await loadWidgetLayout();

    // Make grid responsive
    const updateColumnCount = () => {
      if (!grid) return;
      
      const width = window.innerWidth;
      let columns = 12;
      
      if (width < 641) {
        columns = 1; // Mobile
      } else if (width < 769) {
        columns = 6; // Tablet
      }
      
      grid.column(columns);
    };

    updateColumnCount();
    window.addEventListener('resize', updateColumnCount);

    return () => {
      window.removeEventListener('resize', updateColumnCount);
      if (grid) {
        grid.off('change', handleChange);
        grid.off('added', handleAdded);
        grid.off('removed', handleRemoved);
        grid.destroy();
      }
    };
  });

  // Expose grid methods
  export const addWidget = (widget: GridStackWidget) => {
    if (grid) {
      grid.addWidget(widget);
    }
  };

  export const removeWidget = (id: string) => {
    if (grid) {
      const item = grid.getGridItems().find(el => el.getAttribute('gs-id') === id);
      if (item) {
        grid.removeWidget(item);
      }
    }
  };

  export const updateWidget = (id: string, updates: Partial<GridStackWidget>) => {
    if (grid) {
      grid.update(id, updates);
    }
  };
</script>

<div class="widget-grid-container">
  <div 
    bind:this={gridElement}
    class="widget-grid"
    class:editable={editable}
  >
    <slot />
  </div>
</div>

<style>
  .widget-grid-container {
    width: 100%;
    min-height: 100vh;
    padding: 1rem;
  }

  .widget-grid {
    background-color: transparent;
  }

  :global(.grid-stack-item-content) {
    background-color: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius-lg);
    overflow: hidden;
    transition: all var(--transition-fast);
  }

  :global(.grid-stack-item-content:hover) {
    border-color: var(--border-hover);
  }

  :global(.grid-stack-item-removing) {
    opacity: 0.8;
    filter: blur(2px);
  }

  :global(.grid-stack-placeholder > .placeholder-content) {
    background-color: var(--accent-secondary);
    border: 2px dashed var(--accent-primary);
    border-radius: var(--radius-lg);
  }

  :global(.grid-stack > .grid-stack-item > .grid-stack-item-content) {
    inset: 0;
  }

  :global(.grid-stack > .grid-stack-item > .ui-resizable-handle) {
    filter: none;
  }

  :global(.ui-resizable-se) {
    width: 12px;
    height: 12px;
    background-color: var(--accent-primary);
    border-radius: 2px;
    cursor: se-resize;
  }

  @media (max-width: 640px) {
    .widget-grid-container {
      padding: 0.5rem;
    }
  }
</style>