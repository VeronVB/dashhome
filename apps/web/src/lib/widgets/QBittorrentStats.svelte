<!--
  @file QBittorrentStats.svelte
  @description qBittorrent management widget with authentication and controls
  @author Generated by OK Computer for Michal's Dashboard
  @date 2025-01-07
-->

<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { apiClient } from '$lib/api/client';
  import type { QBittorrentStats, TorrentInfo } from '$lib/api/client';
  import { Download, Upload, Play, Square, Trash2, AlertCircle } from 'lucide-svelte';
  import { fade, scale } from 'svelte/transition';
  import { formatBytes } from '$lib/utils/formatters';

  export let widgetId: string;

  let stats: QBittorrentStats | null = null;
  let torrents: TorrentInfo[] = [];
  let loading = true;
  let error: string | null = null;
  let showAuthModal = false;
  let authLoading = false;
  let authError = '';
  let username = '';
  let password = '';
  let interval: NodeJS.Timeout;

  const formatSpeed = (bytesPerSecond: number): string => {
    if (bytesPerSecond === 0) return '0 B/s';
    const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
    const i = Math.floor(Math.log(bytesPerSecond) / Math.log(1024));
    return Math.round(bytesPerSecond / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
  };

  const loadStats = async () => {
    try {
      stats = await apiClient.getQBittorrentStats();
      error = null;
    } catch (err: any) {
      if (err.message?.includes('401') || err.message?.includes('403')) {
        error = 'Authentication required';
        showAuthModal = true;
      } else {
        error = 'Failed to load qBittorrent stats';
      }
      console.error('qBittorrent error:', err);
    }
  };

  const loadTorrents = async () => {
    try {
      torrents = await apiClient.getTorrents(10);
    } catch (err) {
      console.error('Failed to load torrents:', err);
    }
  };

  const handleAuth = async () => {
    authLoading = true;
    authError = '';
    
    try {
      // Store credentials securely (in production, use secure storage)
      localStorage.setItem('qbittorrent_username', username);
      localStorage.setItem('qbittorrent_password', password);
      
      // Retry loading data
      await loadStats();
      await loadTorrents();
      showAuthModal = false;
      loading = false;
    } catch (err: any) {
      authError = 'Invalid credentials';
    } finally {
      authLoading = false;
    }
  };

  const handleTorrentAction = async (hash: string, action: 'pause' | 'resume' | 'delete') => {
    try {
      switch (action) {
        case 'pause':
          await apiClient.pauseTorrent(hash);
          break;
        case 'resume':
          await apiClient.resumeTorrent(hash);
          break;
        case 'delete':
          if (confirm('Czy na pewno chcesz usunąć ten torrent?')) {
            await apiClient.deleteTorrent(hash);
          }
          break;
      }
      await loadTorrents();
    } catch (err) {
      console.error(`Failed to ${action} torrent:`, err);
    }
  };

  const getStatusColor = (state: string): string => {
    switch (state) {
      case 'downloading': return '#3b82f6';
      case 'uploading': return '#22c55e';
      case 'pausedUP':
      case 'pausedDL': return '#f59e0b';
      case 'error': return '#ef4444';
      default: return '#6b7280';
    }
  };

  const getStatusText = (state: string): string => {
    switch (state) {
      case 'downloading': return 'Pobieranie';
      case 'uploading': return 'Wysyłanie';
      case 'pausedUP': return 'Wstrzymano (ukończone)';
      case 'pausedDL': return 'Wstrzymano (pobieranie)';
      case 'error': return 'Błąd';
      default: return state;
    }
  };

  onMount(async () => {
    // Try to load saved credentials
    const savedUsername = localStorage.getItem('qbittorrent_username');
    const savedPassword = localStorage.getItem('qbittorrent_password');
    
    if (savedUsername && savedPassword) {
      username = savedUsername;
      password = savedPassword;
      await loadStats();
      await loadTorrents();
    } else {
      showAuthModal = true;
    }
    
    loading = false;
    
    // Refresh every 30 seconds
    interval = setInterval(async () => {
      if (!showAuthModal) {
        await loadStats();
        await loadTorrents();
      }
    }, 30000);
  });

  onDestroy(() => {
    if (interval) {
      clearInterval(interval);
    }
  });
</script>

{#if loading}
  <div class="loading-container" transition:fade>
    <div class="loading-spinner"></div>
    <span>Ładowanie qBittorrent...</span>
  </div>
{:else if showAuthModal}
  <div class="auth-container" transition:fade>
    <div class="auth-header">
      <AlertCircle size={32} />
      <h3>Wymagane uwierzytelnienie</h3>
      <p>Podaj dane logowania do qBittorrent</p>
    </div>
    
    <form on:submit|preventDefault={handleAuth} class="auth-form">
      <div class="form-group">
        <label for="username">Nazwa użytkownika</label>
        <input
          id="username"
          type="text"
          bind:value={username}
          required
          placeholder="admin"
        />
      </div>
      
      <div class="form-group">
        <label for="password">Hasło</label>
        <input
          id="password"
          type="password"
          bind:value={password}
          required
          placeholder="••••••••"
        />
      </div>
      
      {#if authError}
        <div class="auth-error" transition:scale>
          {authError}
        </div>
      {/if}
      
      <button type="submit" disabled={authLoading} class="auth-btn">
        {authLoading ? 'Logowanie...' : 'Zaloguj'}
      </button>
    </form>
  </div>
{:else if stats}
  <div class="qbittorrent-container" transition:fade>
    <!-- Speed Stats -->
    <div class="speed-stats">
      <div class="speed-item">
        <Download size={20} />
        <div class="speed-info">
          <span class="speed-label">Pobieranie</span>
          <span class="speed-value">{formatSpeed(stats.download_speed)}</span>
        </div>
      </div>
      
      <div class="speed-item">
        <Upload size={20} />
        <div class="speed-info">
          <span class="speed-label">Wysyłanie</span>
          <span class="speed-value">{formatSpeed(stats.upload_speed)}</span>
        </div>
      </div>
    </div>

    <!-- Torrent Stats -->
    <div class="torrent-stats">
      <div class="stat-box">
        <span class="stat-number">{stats.active_torrents}</span>
        <span class="stat-label">Aktywne</span>
      </div>
      <div class="stat-box">
        <span class="stat-number">{stats.total_torrents}</span>
        <span class="stat-label">Łącznie</span>
      </div>
      <div class="stat-box">
        <span class="stat-number">{stats.completed_torrents}</span>
        <span class="stat-label">Ukończone</span>
      </div>
    </div>

    <!-- Torrent List -->
    {#if torrents.length > 0}
      <div class="torrent-list">
        <h4>Aktywne torrenty</h4>
        {#each torrents as torrent}
          <div class="torrent-item">
            <div class="torrent-info">
              <div class="torrent-name" title={torrent.name}>
                {torrent.name.length > 40 ? torrent.name.substring(0, 40) + '...' : torrent.name}
              </div>
              <div class="torrent-details">
                <span class="torrent-progress">
                  {Math.round(torrent.progress * 100)}%
                </span>
                <span class="torrent-speed">
                  ↓ {formatSpeed(torrent.dlspeed)} • ↑ {formatSpeed(torrent.upspeed)}
                </span>
                <span 
                  class="torrent-status"
                  style="color: {getStatusColor(torrent.state)}"
                >
                  {getStatusText(torrent.state)}
                </span>
              </div>
            </div>
            
            <div class="torrent-actions">
              {#if torrent.state === 'pausedUP' || torrent.state === 'pausedDL'}
                <button
                  class="action-btn action-btn-resume"
                  on:click={() => handleTorrentAction(torrent.hash, 'resume')}
                  title="Wznów"
                >
                  <Play size={14} />
                </button>
              {:else if torrent.state === 'downloading' || torrent.state === 'uploading'}
                <button
                  class="action-btn action-btn-pause"
                  on:click={() => handleTorrentAction(torrent.hash, 'pause')}
                  title="Wstrzymaj"
                >
                  <Square size={14} />
                </button>
              {/if}
              
              <button
                class="action-btn action-btn-delete"
                on:click={() => handleTorrentAction(torrent.hash, 'delete')}
                title="Usuń"
              >
                <Trash2 size={14} />
              </button>
            </div>
          </div>
        {/each}
      </div>
    {:else}
      <div class="no-torrents">
        <p>Brak aktywnych torrentów</p>
      </div>
    {/if}
  </div>
{/if}

<style>
  .loading-container,
  .error-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    gap: 1rem;
    color: var(--text-muted);
    text-align: center;
  }

  .loading-spinner {
    width: 32px;
    height: 32px;
    border: 2px solid var(--border);
    border-top-color: var(--accent-primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  .auth-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    padding: 1rem;
    text-align: center;
  }

  .auth-header {
    margin-bottom: 2rem;
  }

  .auth-header :global(svg) {
    color: var(--accent-primary);
    margin-bottom: 1rem;
  }

  .auth-header h3 {
    color: var(--text-primary);
    margin-bottom: 0.5rem;
  }

  .auth-header p {
    color: var(--text-muted);
    margin: 0;
  }

  .auth-form {
    width: 100%;
    max-width: 300px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .form-group {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    text-align: left;
  }

  .form-group label {
    color: var(--text-secondary);
    font-size: 0.875rem;
    font-weight: 500;
  }

  .form-group input {
    padding: 0.75rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: var(--radius-md);
    color: var(--text-primary);
    font-size: 0.875rem;
    transition: all var(--transition-fast);
  }

  .form-group input:focus {
    outline: none;
    border-color: var(--accent-primary);
    box-shadow: 0 0 0 3px var(--accent-secondary);
  }

  .auth-error {
    padding: 0.75rem;
    background-color: rgba(239, 68, 68, 0.1);
    border: 1px solid rgba(239, 68, 68, 0.3);
    border-radius: var(--radius-md);
    color: #ef4444;
    font-size: 0.875rem;
  }

  .auth-btn {
    padding: 0.75rem 1.5rem;
    background-color: var(--accent-primary);
    color: var(--bg-primary);
    border: none;
    border-radius: var(--radius-md);
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .auth-btn:hover:not(:disabled) {
    filter: brightness(1.1);
    transform: translateY(-1px);
  }

  .auth-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  .qbittorrent-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 0.5rem;
  }

  .speed-stats {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 1rem;
  }

  .speed-item {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background-color: var(--bg-secondary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
  }

  .speed-item :global(svg) {
    color: var(--accent-primary);
    flex-shrink: 0;
  }

  .speed-info {
    display: flex;
    flex-direction: column;
  }

  .speed-label {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 0.25rem;
  }

  .speed-value {
    font-size: 1rem;
    font-weight: 600;
    color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace;
  }

  .torrent-stats {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
  }

  .stat-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 1rem;
    background-color: var(--bg-secondary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
    text-align: center;
  }

  .stat-number {
    font-size: 1.5rem;
    font-weight: 600;
    color: var(--accent-primary);
    margin-bottom: 0.25rem;
  }

  .stat-label {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .torrent-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .torrent-list h4 {
    color: var(--text-primary);
    margin: 0 0 0.5rem 0;
    font-size: 1rem;
  }

  .torrent-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem;
    background-color: var(--bg-secondary);
    border-radius: var(--radius-md);
    border: 1px solid var(--border);
    transition: all var(--transition-fast);
  }

  .torrent-item:hover {
    border-color: var(--border-hover);
  }

  .torrent-info {
    flex: 1;
    min-width: 0;
    margin-right: 1rem;
  }

  .torrent-name {
    color: var(--text-primary);
    font-size: 0.875rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .torrent-details {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 0.75rem;
  }

  .torrent-progress {
    color: var(--accent-primary);
    font-weight: 500;
  }

  .torrent-speed {
    color: var(--text-muted);
    font-family: 'JetBrains Mono', monospace;
  }

  .torrent-status {
    font-weight: 500;
  }

  .torrent-actions {
    display: flex;
    gap: 0.25rem;
  }

  .action-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 28px;
    height: 28px;
    background: none;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .action-btn:hover {
    background-color: var(--bg-hover);
  }

  .action-btn-resume:hover {
    border-color: #22c55e;
    color: #22c55e;
  }

  .action-btn-pause:hover {
    border-color: #f59e0b;
    color: #f59e0b;
  }

  .action-btn-delete:hover {
    border-color: #ef4444;
    color: #ef4444;
  }

  .no-torrents {
    padding: 2rem;
    text-align: center;
    color: var(--text-muted);
  }

  @media (max-width: 640px) {
    .qbittorrent-container {
      padding: 0.25rem;
    }

    .speed-stats,
    .torrent-stats {
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }

    .torrent-details {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.25rem;
    }

    .torrent-actions {
      flex-direction: column;
    }
  }
</style>