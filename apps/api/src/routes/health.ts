/**
 * @file health.ts
 * @description Health check endpoints using Zod for validation and typing
 * @author Generated by Gemini for Michal's Dashboard
 */

import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { checkDatabaseConnection } from '../db/client';
import { cacheService } from '../services/cache.service';
import { dockerService } from '../services/docker.service';
import { proxmoxService } from '../services/proxmox.service';

// --- SCHEMATY ZOD ---

const healthResponseSchema = z.object({
  status: z.string(),
  timestamp: z.string().datetime(),
  uptime: z.number(),
  version: z.string(),
});

const serviceStatusSchema = z.object({
  status: z.enum(['healthy', 'unhealthy', 'not_configured']),
  latency: z.number().optional(),
});

const detailedHealthResponseSchema = z.object({
  status: z.enum(['healthy', 'degraded']),
  timestamp: z.string().datetime(),
  services: z.object({
    database: serviceStatusSchema,
    redis: serviceStatusSchema,
    docker: serviceStatusSchema,
    proxmox: serviceStatusSchema,
  }),
});

// --- ROUTY ---

export default async function healthRoutes(fastify: FastifyInstance) {
  /**
   * GET /health
   * Podstawowy health check
   */
  fastify.get('/health', async (request: FastifyRequest, reply: FastifyReply) => {
    const data = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      uptime: Math.round(process.uptime()),
      version: process.env.npm_package_version || '1.0.0',
    };

    // Walidacja danych przed wysyłką (opcjonalna, ale dobra dla pewności typów)
    const result = healthResponseSchema.safeParse(data);
    if (!result.success) {
      return reply.code(500).send({ error: 'Internal Server Error: Invalid health data' });
    }

    return reply.send(result.data);
  });

  /**
   * GET /health/detailed
   * Szczegółowy status wszystkich serwisów zależnych
   */
  fastify.get('/health/detailed', async (request: FastifyRequest, reply: FastifyReply) => {
    const startTime = Date.now();
    
    // Sprawdzenie Bazy Danych
    const dbStart = Date.now();
    const dbHealthy = await checkDatabaseConnection();
    const databaseStatus = {
      status: dbHealthy ? 'healthy' : ('unhealthy' as const),
      latency: Date.now() - dbStart,
    };

    // Sprawdzenie Redis
    const redisStart = Date.now();
    let redisStatus;
    try {
      await cacheService.exists('health:check');
      redisStatus = { status: 'healthy' as const, latency: Date.now() - redisStart };
    } catch {
      redisStatus = { status: 'unhealthy' as const, latency: Date.now() - redisStart };
    }

    // Sprawdzenie Docker
    let dockerStatus;
    try {
      await dockerService.listContainers();
      dockerStatus = { status: 'healthy' as const };
    } catch {
      dockerStatus = { status: 'unhealthy' as const };
    }

    // Sprawdzenie Proxmox
    let proxmoxStatus;
    if (proxmoxService.isConfigured()) {
      try {
        await proxmoxService.getNodes();
        proxmoxStatus = { status: 'healthy' as const };
      } catch {
        proxmoxStatus = { status: 'unhealthy' as const };
      }
    } else {
      proxmoxStatus = { status: 'not_configured' as const };
    }

    // Obliczenie ogólnego statusu
    const services = {
      database: databaseStatus,
      redis: redisStatus,
      docker: dockerStatus,
      proxmox: proxmoxStatus,
    };

    const isAnyCriticalUnhealthy = [databaseStatus.status, redisStatus.status, dockerStatus.status]
      .some(status => status === 'unhealthy');

    const responseData = {
      status: isAnyCriticalUnhealthy ? ('degraded' as const) : ('healthy' as const),
      timestamp: new Date().toISOString(),
      services,
    };

    // Walidacja Zod
    const result = detailedHealthResponseSchema.safeParse(responseData);
    
    if (!result.success) {
      return reply.code(500).send({ 
        error: 'Detailed health check validation failed', 
        details: result.error.format() 
      });
    }

    return reply.send(result.data);
  });
}