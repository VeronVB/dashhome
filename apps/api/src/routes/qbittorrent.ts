/**
 * @file qbittorrent.ts
 * @description qBittorrent API proxy endpoints
 * @author Generated by OK Computer for Michal's Dashboard
 * @date 2025-01-07
 */

import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import axios, { AxiosInstance } from 'axios';
import { cacheService } from '../services/cache.service';
import { logger } from '../utils/logger';

interface QBittorrentStats {
  download_speed: number;
  upload_speed: number;
  active_torrents: number;
  total_torrents: number;
  completed_torrents: number;
  paused_torrents: number;
}

interface TorrentInfo {
  hash: string;
  name: string;
  size: number;
  progress: number;
  dlspeed: number;
  upspeed: number;
  priority: string;
  num_seeds: number;
  num_complete: number;
  num_leechs: number;
  state: string;
  eta: number;
}

class QBittorrentService {
  private api: AxiosInstance | null = null;
  private cookie: string | null = null;
  private baseUrl: string;
  private username: string;
  private password: string;

  constructor() {
    this.baseUrl = process.env.QBITTORRENT_URL || '';
    this.username = process.env.QBITTORRENT_USER || '';
    this.password = process.env.QBITTORRENT_PASS || '';

    if (this.baseUrl && this.username && this.password) {
      this.api = axios.create({
        baseURL: `${this.baseUrl}/api/v2`,
        timeout: 10000,
      });
      
      // Add cookie to requests
      this.api.interceptors.request.use((config) => {
        if (this.cookie) {
          config.headers.Cookie = this.cookie;
        }
        return config;
      });
    }
  }

  private async authenticate(): Promise<void> {
    if (!this.api) {
      throw new Error('qBittorrent API not configured');
    }

    try {
      const response = await this.api.post('/auth/login', {
        username: this.username,
        password: this.password,
      }, {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded',
        },
      });

      const setCookieHeader = response.headers['set-cookie'];
      if (setCookieHeader && setCookieHeader.length > 0) {
        this.cookie = setCookieHeader[0].split(';')[0];
        logger.debug('qBittorrent authentication successful');
      } else {
        throw new Error('No cookie received from qBittorrent');
      }
    } catch (error) {
      logger.error('qBittorrent authentication failed:', error);
      throw error;
    }
  }

  private async ensureAuthenticated(): Promise<void> {
    if (!this.cookie) {
      await this.authenticate();
    }
  }

  async getStats(): Promise<QBittorrentStats> {
    const cacheKey = 'qbittorrent:stats';
    const cached = await cacheService.get<QBittorrentStats>(cacheKey);
    
    if (cached) {
      return cached;
    }

    await this.ensureAuthenticated();

    try {
      const [transferInfo, torrentsList] = await Promise.all([
        this.api!.get('/transfer/info'),
        this.api!.get('/torrents/info'),
      ]);

      const activeTorrents = torrentsList.data.filter((t: any) => t.state === 'downloading' || t.state === 'uploading');

      const stats: QBittorrentStats = {
        download_speed: transferInfo.data.dl_info_speed || 0,
        upload_speed: transferInfo.data.up_info_speed || 0,
        active_torrents: activeTorrents.length,
        total_torrents: torrentsList.data.length,
        completed_torrents: torrentsList.data.filter((t: any) => t.progress === 1).length,
        paused_torrents: torrentsList.data.filter((t: any) => t.state === 'pausedUP' || t.state === 'pausedDL').length,
      };

      await cacheService.set(cacheKey, stats, 30); // 30 second cache
      return stats;
    } catch (error: any) {
      if (error.response?.status === 403) {
        // Authentication expired, retry
        this.cookie = null;
        return this.getStats();
      }
      logger.error('Failed to fetch qBittorrent stats:', error);
      throw error;
    }
  }

  async getTorrents(limit: number = 10): Promise<TorrentInfo[]> {
    await this.ensureAuthenticated();

    try {
      const response = await this.api!.get('/torrents/info', {
        params: { limit, sort: 'added_on' },
      });

      return response.data.map((torrent: any) => ({
        hash: torrent.hash,
        name: torrent.name,
        size: torrent.size,
        progress: torrent.progress,
        dlspeed: torrent.dlspeed,
        upspeed: torrent.upspeed,
        priority: torrent.priority,
        num_seeds: torrent.num_seeds,
        num_complete: torrent.num_complete,
        num_leechs: torrent.num_leechs,
        state: torrent.state,
        eta: torrent.eta,
      }));
    } catch (error: any) {
      if (error.response?.status === 403) {
        // Authentication expired, retry
        this.cookie = null;
        return this.getTorrents(limit);
      }
      logger.error('Failed to fetch qBittorrent torrents:', error);
      throw error;
    }
  }

  async pauseTorrent(hash: string): Promise<void> {
    await this.ensureAuthenticated();

    try {
      await this.api!.post('/torrents/pause', `hashes=${hash}`, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
      logger.info(`Torrent ${hash} paused`);
    } catch (error) {
      logger.error(`Failed to pause torrent ${hash}:`, error);
      throw error;
    }
  }

  async resumeTorrent(hash: string): Promise<void> {
    await this.ensureAuthenticated();

    try {
      await this.api!.post('/torrents/resume', `hashes=${hash}`, {
        headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      });
      logger.info(`Torrent ${hash} resumed`);
    } catch (error) {
      logger.error(`Failed to resume torrent ${hash}:`, error);
      throw error;
    }
  }

  isConfigured(): boolean {
    return !!(this.api && this.baseUrl && this.username && this.password);
  }
}

const qbittorrentService = new QBittorrentService();

export default async function qbittorrentRoutes(fastify: FastifyInstance) {
  if (!qbittorrentService.isConfigured()) {
    fastify.log.warn('qBittorrent service not configured, skipping routes');
    return;
  }

  /**
   * @GET /api/qbittorrent/stats
   * @description Get qBittorrent statistics
   */
  fastify.get('/api/qbittorrent/stats', {
    schema: {
      tags: ['qBittorrent'],
      summary: 'Get qBittorrent stats',
      description: 'Retrieve qBittorrent transfer statistics',
      response: {
        200: {
          type: 'object',
          properties: {
            download_speed: { type: 'number' },
            upload_speed: { type: 'number' },
            active_torrents: { type: 'number' },
            total_torrents: { type: 'number' },
            completed_torrents: { type: 'number' },
            paused_torrents: { type: 'number' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const stats = await qbittorrentService.getStats();
      reply.send(stats);
    } catch (error) {
      logger.error('Failed to fetch qBittorrent stats:', error);
      reply.code(500).send({ error: 'Failed to fetch qBittorrent statistics' });
    }
  });

  /**
   * @GET /api/qbittorrent/torrents
   * @description Get qBittorrent torrents list
   */
  fastify.get('/api/qbittorrent/torrents', {
    schema: {
      tags: ['qBittorrent'],
      summary: 'List torrents',
      description: 'Retrieve list of torrents',
      querystring: {
        type: 'object',
        properties: {
          limit: { type: 'number', minimum: 1, maximum: 50, default: 10 },
        },
      },
      response: {
        200: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              hash: { type: 'string' },
              name: { type: 'string' },
              size: { type: 'number' },
              progress: { type: 'number' },
              dlspeed: { type: 'number' },
              upspeed: { type: 'number' },
              priority: { type: 'string' },
              num_seeds: { type: 'number' },
              num_complete: { type: 'number' },
              num_leechs: { type: 'number' },
              state: { type: 'string' },
              eta: { type: 'number' },
            },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const query = z.object({ limit: z.coerce.number().min(1).max(50).default(10) }).parse(request.query);
    
    try {
      const torrents = await qbittorrentService.getTorrents(query.limit);
      reply.send(torrents);
    } catch (error) {
      logger.error('Failed to fetch qBittorrent torrents:', error);
      reply.code(500).send({ error: 'Failed to fetch torrents' });
    }
  });

  /**
   * @POST /api/qbittorrent/torrents/:hash/pause
   * @description Pause a torrent
   */
  fastify.post('/api/qbittorrent/torrents/:hash/pause', {
    schema: {
      tags: ['qBittorrent'],
      summary: 'Pause torrent',
      description: 'Pause a specific torrent',
      params: {
        type: 'object',
        properties: {
          hash: { type: 'string' },
        },
        required: ['hash'],
      },
      response: {
        200: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            message: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const params = z.object({ hash: z.string() }).parse(request.params);
    
    try {
      await qbittorrentService.pauseTorrent(params.hash);
      reply.send({
        success: true,
        message: 'Torrent paused successfully',
      });
    } catch (error) {
      logger.error(`Failed to pause torrent ${params.hash}:`, error);
      reply.code(500).send({ error: 'Failed to pause torrent' });
    }
  });

  /**
   * @POST /api/qbittorrent/torrents/:hash/resume
   * @description Resume a torrent
   */
  fastify.post('/api/qbittorrent/torrents/:hash/resume', {
    schema: {
      tags: ['qBittorrent'],
      summary: 'Resume torrent',
      description: 'Resume a specific torrent',
      params: {
        type: 'object',
        properties: {
          hash: { type: 'string' },
        },
        required: ['hash'],
      },
      response: {
        200: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            message: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const params = z.object({ hash: z.string() }).parse(request.params);
    
    try {
      await qbittorrentService.resumeTorrent(params.hash);
      reply.send({
        success: true,
        message: 'Torrent resumed successfully',
      });
    } catch (error) {
      logger.error(`Failed to resume torrent ${params.hash}:`, error);
      reply.code(500).send({ error: 'Failed to resume torrent' });
    }
  });
}