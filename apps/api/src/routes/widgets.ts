/**
 * @file widgets.ts
 * @description Widget configuration CRUD endpoints
 * @author Generated by OK Computer for Michal's Dashboard
 * @date 2025-01-07
 */

import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { z } from 'zod';
import { db } from '../db/client';
import { widgets, insertWidgetSchema, selectWidgetSchema } from '../db/schema';
import { eq } from 'drizzle-orm';
import { logger } from '../utils/logger';

const widgetQuerySchema = z.object({
  type: z.enum(['system-stats', 'docker-quick', 'pihole-stats', 'qbittorrent-stats', 'notes']).optional(),
});

const widgetParamsSchema = z.object({
  id: z.string().uuid(),
});

export default async function widgetRoutes(fastify: FastifyInstance) {
  /**
   * @GET /api/widgets
   * @description Get all widgets with optional type filter
   */
  fastify.get('/api/widgets', {
    schema: {
      tags: ['Widgets'],
      summary: 'List widgets',
      description: 'Retrieve all widgets or filter by type',
      querystring: {
        type: 'object',
        properties: {
          type: { 
            type: 'string', 
            enum: ['system-stats', 'docker-quick', 'pihole-stats', 'qbittorrent-stats', 'notes'] 
          },
        },
      },
      response: {
        200: {
          type: 'array',
          items: selectWidgetSchema,
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const query = widgetQuerySchema.parse(request.query);
    
    try {
      let widgetList;
      if (query.type) {
        widgetList = await db.select().from(widgets).where(eq(widgets.type, query.type));
      } else {
        widgetList = await db.select().from(widgets);
      }
      
      reply.send(widgetList);
    } catch (error) {
      logger.error('Failed to fetch widgets:', error);
      reply.code(500).send({ error: 'Failed to fetch widgets' });
    }
  });

  /**
   * @POST /api/widgets
   * @description Create a new widget
   */
  fastify.post('/api/widgets', {
    schema: {
      tags: ['Widgets'],
      summary: 'Create widget',
      description: 'Create a new widget configuration',
      body: insertWidgetSchema,
      response: {
        201: selectWidgetSchema,
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const widgetData = insertWidgetSchema.parse(request.body);
    
    try {
      const [newWidget] = await db.insert(widgets).values(widgetData).returning();
      logger.info(`Widget created: ${newWidget.id} (${newWidget.type})`);
      reply.code(201).send(newWidget);
    } catch (error) {
      logger.error('Failed to create widget:', error);
      reply.code(500).send({ error: 'Failed to create widget' });
    }
  });

  /**
   * @GET /api/widgets/:id
   * @description Get a specific widget by ID
   */
  fastify.get('/api/widgets/:id', {
    schema: {
      tags: ['Widgets'],
      summary: 'Get widget',
      description: 'Retrieve a specific widget by ID',
      params: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
        },
        required: ['id'],
      },
      response: {
        200: selectWidgetSchema,
        404: {
          type: 'object',
          properties: {
            error: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const params = widgetParamsSchema.parse(request.params);
    
    try {
      const [widget] = await db.select().from(widgets).where(eq(widgets.id, params.id));
      
      if (!widget) {
        reply.code(404).send({ error: 'Widget not found' });
        return;
      }
      
      reply.send(widget);
    } catch (error) {
      logger.error(`Failed to fetch widget ${params.id}:`, error);
      reply.code(500).send({ error: 'Failed to fetch widget' });
    }
  });

  /**
   * @PUT /api/widgets/:id
   * @description Update a widget
   */
  fastify.put('/api/widgets/:id', {
    schema: {
      tags: ['Widgets'],
      summary: 'Update widget',
      description: 'Update an existing widget configuration',
      params: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
        },
        required: ['id'],
      },
      body: insertWidgetSchema.partial(),
      response: {
        200: selectWidgetSchema,
        404: {
          type: 'object',
          properties: {
            error: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const params = widgetParamsSchema.parse(request.params);
    const updateData = insertWidgetSchema.partial().parse(request.body);
    
    try {
      const [updatedWidget] = await db
        .update(widgets)
        .set({ ...updateData, updatedAt: new Date() })
        .where(eq(widgets.id, params.id))
        .returning();
      
      if (!updatedWidget) {
        reply.code(404).send({ error: 'Widget not found' });
        return;
      }
      
      logger.info(`Widget updated: ${updatedWidget.id}`);
      reply.send(updatedWidget);
    } catch (error) {
      logger.error(`Failed to update widget ${params.id}:`, error);
      reply.code(500).send({ error: 'Failed to update widget' });
    }
  });

  /**
   * @DELETE /api/widgets/:id
   * @description Delete a widget
   */
  fastify.delete('/api/widgets/:id', {
    schema: {
      tags: ['Widgets'],
      summary: 'Delete widget',
      description: 'Delete a widget configuration',
      params: {
        type: 'object',
        properties: {
          id: { type: 'string', format: 'uuid' },
        },
        required: ['id'],
      },
      response: {
        204: {
          type: 'null',
          description: 'Widget deleted successfully',
        },
        404: {
          type: 'object',
          properties: {
            error: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const params = widgetParamsSchema.parse(request.params);
    
    try {
      const [deletedWidget] = await db.delete(widgets).where(eq(widgets.id, params.id)).returning();
      
      if (!deletedWidget) {
        reply.code(404).send({ error: 'Widget not found' });
        return;
      }
      
      logger.info(`Widget deleted: ${params.id}`);
      reply.code(204).send();
    } catch (error) {
      logger.error(`Failed to delete widget ${params.id}:`, error);
      reply.code(500).send({ error: 'Failed to delete widget' });
    }
  });
}