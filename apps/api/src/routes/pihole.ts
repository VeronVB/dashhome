/**
 * @file pihole.ts
 * @description Pi-hole API proxy endpoints
 * @author Generated by OK Computer for Michal's Dashboard
 * @date 2025-01-07
 */

import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import axios from 'axios';
import { cacheService } from '../services/cache.service';
import { logger } from '../utils/logger';
import { z } from 'zod';

interface PiHoleStats {
  queries_today: number;
  blocked_today: number;
  percentage_blocked: number;
  status: 'enabled' | 'disabled';
  unique_clients: number;
  domains_being_blocked: number;
}

class PiHoleService {
  private apiUrl: string;
  private token: string;

  constructor() {
    this.apiUrl = process.env.PIHOLE_API || '';
    this.token = process.env.PIHOLE_TOKEN || '';
  }

  private async makeRequest(endpoint: string, params: Record<string, any> = {}): Promise<any> {
    if (!this.apiUrl || !this.token) {
      throw new Error('Pi-hole API not configured');
    }

    try {
      const response = await axios.get(`${this.apiUrl}${endpoint}`, {
        params: { ...params, auth: this.token },
        timeout: 5000,
      });
      return response.data;
    } catch (error) {
      logger.error(`Pi-hole API request failed for ${endpoint}:`, error);
      throw new Error(`Pi-hole API request failed`);
    }
  }

  async getStats(): Promise<PiHoleStats> {
    const cacheKey = 'pihole:stats';
    const cached = await cacheService.get<PiHoleStats>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const data = await this.makeRequest('', { summary: true });
      
      const stats: PiHoleStats = {
        queries_today: parseInt(data.dns_queries_today) || 0,
        blocked_today: parseInt(data.ads_blocked_today) || 0,
        percentage_blocked: parseFloat(data.ads_percentage_today) || 0,
        status: data.status === 'enabled' ? 'enabled' : 'disabled',
        unique_clients: parseInt(data.unique_clients) || 0,
        domains_being_blocked: parseInt(data.domains_being_blocked) || 0,
      };

      await cacheService.set(cacheKey, stats, 60); // 1 minute cache
      return stats;
    } catch (error) {
      logger.error('Failed to fetch Pi-hole stats:', error);
      throw error;
    }
  }

  async toggleStatus(enable: boolean): Promise<void> {
    try {
      await this.makeRequest('', { 
        enable: enable ? 'true' : 'false' 
      });
      logger.info(`Pi-hole ${enable ? 'enabled' : 'disabled'}`);
      
      // Clear cache
      await cacheService.del('pihole:stats');
    } catch (error) {
      logger.error(`Failed to ${enable ? 'enable' : 'disable'} Pi-hole:`, error);
      throw error;
    }
  }

  async getTopItems(limit: number = 10): Promise<{ topQueries: string[]; topAds: string[] }> {
    try {
      const [topQueries, topAds] = await Promise.all([
        this.makeRequest('', { topItems: limit }),
        this.makeRequest('', { topItemsBlocked: limit }),
      ]);

      return {
        topQueries: topQueries.top_queries || [],
        topAds: topAds.top_ads || [],
      };
    } catch (error) {
      logger.error('Failed to fetch Pi-hole top items:', error);
      throw error;
    }
  }

  isConfigured(): boolean {
    return !!(this.apiUrl && this.token);
  }
}

const piholeService = new PiHoleService();

export default async function piholeRoutes(fastify: FastifyInstance) {
  if (!piholeService.isConfigured()) {
    fastify.log.warn('Pi-hole service not configured, skipping routes');
    return;
  }

  /**
   * @GET /api/pihole/stats
   * @description Get Pi-hole statistics
   */
  fastify.get('/api/pihole/stats', {
    schema: {
      tags: ['Pi-hole'],
      summary: 'Get Pi-hole stats',
      description: 'Retrieve Pi-hole statistics',
      response: {
        200: {
          type: 'object',
          properties: {
            queries_today: { type: 'number' },
            blocked_today: { type: 'number' },
            percentage_blocked: { type: 'number' },
            status: { type: 'string' },
            unique_clients: { type: 'number' },
            domains_being_blocked: { type: 'number' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      const stats = await piholeService.getStats();
      reply.send(stats);
    } catch (error) {
      logger.error('Failed to fetch Pi-hole stats:', error);
      reply.code(500).send({ error: 'Failed to fetch Pi-hole statistics' });
    }
  });

  /**
   * @POST /api/pihole/toggle
   * @description Toggle Pi-hole status
   */
  fastify.post('/api/pihole/toggle', {
    schema: {
      tags: ['Pi-hole'],
      summary: 'Toggle Pi-hole',
      description: 'Enable or disable Pi-hole',
      body: {
        type: 'object',
        properties: {
          enable: { type: 'boolean' },
        },
        required: ['enable'],
      },
      response: {
        200: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            message: { type: 'string' },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const body = z.object({ enable: z.boolean() }).parse(request.body);
    
    try {
      await piholeService.toggleStatus(body.enable);
      reply.send({
        success: true,
        message: `Pi-hole ${body.enable ? 'enabled' : 'disabled'} successfully`,
      });
    } catch (error) {
      logger.error(`Failed to toggle Pi-hole:`, error);
      reply.code(500).send({ error: 'Failed to toggle Pi-hole' });
    }
  });

  /**
   * @GET /api/pihole/top
   * @description Get top queried and blocked domains
   */
  fastify.get('/api/pihole/top', {
    schema: {
      tags: ['Pi-hole'],
      summary: 'Get top domains',
      description: 'Retrieve top queried and blocked domains',
      querystring: {
        type: 'object',
        properties: {
          limit: { type: 'number', minimum: 1, maximum: 50, default: 10 },
        },
      },
      response: {
        200: {
          type: 'object',
          properties: {
            topQueries: {
              type: 'array',
              items: { type: 'string' },
            },
            topAds: {
              type: 'array',
              items: { type: 'string' },
            },
          },
        },
      },
    },
  }, async (request: FastifyRequest, reply: FastifyReply) => {
    const query = z.object({ limit: z.coerce.number().min(1).max(50).default(10) }).parse(request.query);
    
    try {
      const topItems = await piholeService.getTopItems(query.limit);
      reply.send(topItems);
    } catch (error) {
      logger.error('Failed to fetch Pi-hole top items:', error);
      reply.code(500).send({ error: 'Failed to fetch top domains' });
    }
  });
}