/**
 * @file docker.service.ts
 * @description Docker API client service using Dockerode
 * @author Generated by OK Computer for Michal's Dashboard
 * @date 2025-01-07
 */

import Docker from 'dockerode';
import { logger } from '../utils/logger';
import { cacheService } from './cache.service';

export interface ContainerInfo {
  id: string;
  name: string;
  image: string;
  status: 'running' | 'exited' | 'paused' | 'restarting';
  state: string;
  ports: Array<{
    privatePort: number;
    publicPort?: number;
    type: 'tcp' | 'udp';
  }>;
  created: Date;
}

export interface ContainerStats {
  cpuUsage: number;
  memoryUsage: number;
  memoryLimit: number;
  networkIO: {
    rxBytes: number;
    txBytes: number;
  };
}

class DockerService {
  private docker: Docker;

  constructor() {
    this.docker = new Docker({
      socketPath: process.env.DOCKER_SOCKET || '/var/run/docker.sock',
    });
  }

  async listContainers(all: boolean = false): Promise<ContainerInfo[]> {
    const cacheKey = `docker:containers:${all}`;
    const cached = await cacheService.get<ContainerInfo[]>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const containers = await this.docker.listContainers({ all });
      const containerInfo: ContainerInfo[] = containers.map(container => ({
        id: container.Id.substring(0, 12),
        name: container.Names[0]?.replace('/', '') || 'unknown',
        image: container.Image,
        status: container.State as ContainerInfo['status'],
        state: container.Status,
        ports: container.Ports?.map(port => ({
          privatePort: port.PrivatePort,
          publicPort: port.PublicPort,
          type: port.Type as 'tcp' | 'udp',
        })) || [],
        created: new Date(container.Created * 1000),
      }));

      await cacheService.set(cacheKey, containerInfo, 30); // 30 second cache
      return containerInfo;
    } catch (error) {
      logger.error('Failed to list Docker containers:', error);
      throw new Error('Failed to fetch Docker containers');
    }
  }

  async getContainerStats(containerId: string): Promise<ContainerStats> {
    const cacheKey = `docker:stats:${containerId}`;
    const cached = await cacheService.get<ContainerStats>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const container = this.docker.getContainer(containerId);
      const stats = await container.stats({ stream: false });

      const cpuDelta = stats.cpu_stats.cpu_usage.total_usage - stats.precpu_stats.cpu_usage.total_usage;
      const systemDelta = stats.cpu_stats.system_cpu_usage - stats.precpu_stats.system_cpu_usage;
      const cpuUsage = (cpuDelta / systemDelta) * 100;

      const memoryUsage = stats.memory_stats.usage;
      const memoryLimit = stats.memory_stats.limit;

      const networkIO = stats.networks?.eth0 || { rx_bytes: 0, tx_bytes: 0 };

      const containerStats: ContainerStats = {
        cpuUsage: Math.round(cpuUsage * 100) / 100,
        memoryUsage,
        memoryLimit,
        networkIO: {
          rxBytes: networkIO.rx_bytes,
          txBytes: networkIO.tx_bytes,
        },
      };

      await cacheService.set(cacheKey, containerStats, 5); // 5 second cache
      return containerStats;
    } catch (error) {
      logger.error(`Failed to get container stats for ${containerId}:`, error);
      throw new Error(`Failed to fetch container stats for ${containerId}`);
    }
  }

  async startContainer(containerId: string): Promise<void> {
    try {
      const container = this.docker.getContainer(containerId);
      await container.start();
      logger.info(`Container ${containerId} started`);
      
      // Clear cache
      await cacheService.del('docker:containers:true');
      await cacheService.del('docker:containers:false');
    } catch (error) {
      logger.error(`Failed to start container ${containerId}:`, error);
      throw new Error(`Failed to start container ${containerId}`);
    }
  }

  async stopContainer(containerId: string): Promise<void> {
    try {
      const container = this.docker.getContainer(containerId);
      await container.stop();
      logger.info(`Container ${containerId} stopped`);
      
      // Clear cache
      await cacheService.del('docker:containers:true');
      await cacheService.del('docker:containers:false');
    } catch (error) {
      logger.error(`Failed to stop container ${containerId}:`, error);
      throw new Error(`Failed to stop container ${containerId}`);
    }
  }

  async restartContainer(containerId: string): Promise<void> {
    try {
      const container = this.docker.getContainer(containerId);
      await container.restart();
      logger.info(`Container ${containerId} restarted`);
      
      // Clear cache
      await cacheService.del('docker:containers:true');
      await cacheService.del('docker:containers:false');
    } catch (error) {
      logger.error(`Failed to restart container ${containerId}:`, error);
      throw new Error(`Failed to restart container ${containerId}`);
    }
  }

  async getSystemInfo(): Promise<{ containers: number; images: number; volumes: number; networks: number }> {
    try {
      const [containers, images, volumes, networks] = await Promise.all([
        this.docker.listContainers({ all: true }),
        this.docker.listImages(),
        this.docker.listVolumes(),
        this.docker.listNetworks(),
      ]);

      return {
        containers: containers.length,
        images: images.length,
        volumes: volumes.volumes?.length || 0,
        networks: networks.length,
      };
    } catch (error) {
      logger.error('Failed to get Docker system info:', error);
      throw new Error('Failed to fetch Docker system info');
    }
  }
}

export const dockerService = new DockerService();