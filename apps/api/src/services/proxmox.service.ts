/**
 * @file proxmox.service.ts
 * @description Proxmox VE API client service
 * @author Generated by OK Computer for Michal's Dashboard
 * @date 2025-01-07
 */

import axios, { AxiosInstance } from 'axios';
import { logger } from '../utils/logger';
import { cacheService } from './cache.service';

export interface ProxmoxNode {
  node: string;
  status: 'online' | 'offline';
  cpu: number;
  maxcpu: number;
  mem: number;
  maxmem: number;
  disk: number;
  maxdisk: number;
}

export interface ProxmoxVM {
  vmid: number;
  name: string;
  status: 'running' | 'stopped' | 'paused';
  cpu: number;
  maxcpu: number;
  mem: number;
  maxmem: number;
  disk: number;
  maxdisk: number;
  type: 'qemu' | 'lxc';
}

export interface ProxmoxStorage {
  storage: string;
  type: string;
  content: string;
  used: number;
  total: number;
  available: number;
}

class ProxmoxService {
  private api: AxiosInstance | null = null;
  private tokenId: string;
  private tokenSecret: string;
  private baseUrl: string;

  constructor() {
    this.tokenId = process.env.PROXMOX_TOKEN_ID || '';
    this.tokenSecret = process.env.PROXMOX_TOKEN_SECRET || '';
    this.baseUrl = process.env.PROXMOX_API || '';

    if (this.tokenId && this.tokenSecret && this.baseUrl) {
      this.api = axios.create({
        baseURL: this.baseUrl,
        headers: {
          'Authorization': `PVEAPIToken=${this.tokenId}=${this.tokenSecret}`,
        },
        httpsAgent: new (require('https').Agent)({
          rejectUnauthorized: false, // Proxmox uses self-signed certificates
        }),
      });

      logger.info('Proxmox service initialized');
    } else {
      logger.warn('Proxmox service not configured - missing environment variables');
    }
  }

  private async makeRequest<T>(endpoint: string): Promise<T> {
    if (!this.api) {
      throw new Error('Proxmox API not configured');
    }

    try {
      const response = await this.api.get(endpoint);
      return response.data.data;
    } catch (error) {
      logger.error(`Proxmox API request failed for ${endpoint}:`, error);
      throw new Error(`Proxmox API request failed for ${endpoint}`);
    }
  }

  async getNodes(): Promise<ProxmoxNode[]> {
    const cacheKey = 'proxmox:nodes';
    const cached = await cacheService.get<ProxmoxNode[]>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const nodes = await this.makeRequest<ProxmoxNode[]>('/nodes');
      await cacheService.set(cacheKey, nodes, 60); // 1 minute cache
      return nodes;
    } catch (error) {
      logger.error('Failed to fetch Proxmox nodes:', error);
      throw error;
    }
  }

  async getVMs(node: string): Promise<ProxmoxVM[]> {
    const cacheKey = `proxmox:vms:${node}`;
    const cached = await cacheService.get<ProxmoxVM[]>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const [qemuVms, lxcContainers] = await Promise.all([
        this.makeRequest<ProxmoxVM[]>(`/nodes/${node}/qemu`),
        this.makeRequest<ProxmoxVM[]>(`/nodes/${node}/lxc`),
      ]);

      const allVms = [
        ...qemuVms.map(vm => ({ ...vm, type: 'qemu' as const })),
        ...lxcContainers.map(ct => ({ ...ct, type: 'lxc' as const })),
      ];

      await cacheService.set(cacheKey, allVms, 30); // 30 second cache
      return allVms;
    } catch (error) {
      logger.error(`Failed to fetch VMs for node ${node}:`, error);
      throw error;
    }
  }

  async getStorage(node: string): Promise<ProxmoxStorage[]> {
    const cacheKey = `proxmox:storage:${node}`;
    const cached = await cacheService.get<ProxmoxStorage[]>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const storage = await this.makeRequest<ProxmoxStorage[]>(`/nodes/${node}/storage`);
      await cacheService.set(cacheKey, storage, 300); // 5 minute cache
      return storage;
    } catch (error) {
      logger.error(`Failed to fetch storage for node ${node}:`, error);
      throw error;
    }
  }

  async getClusterStatus(): Promise<{ cluster: any; quorum: any }> {
    const cacheKey = 'proxmox:cluster';
    const cached = await cacheService.get<{ cluster: any; quorum: any }>(cacheKey);
    
    if (cached) {
      return cached;
    }

    try {
      const [cluster, quorum] = await Promise.all([
        this.makeRequest('/cluster/status'),
        this.makeRequest('/cluster/quorum/status'),
      ]);

      const result = { cluster, quorum };
      await cacheService.set(cacheKey, result, 60); // 1 minute cache
      return result;
    } catch (error) {
      logger.error('Failed to fetch cluster status:', error);
      throw error;
    }
  }

  async startVM(node: string, vmid: number, type: 'qemu' | 'lxc'): Promise<void> {
    try {
      const endpoint = type === 'qemu' 
        ? `/nodes/${node}/qemu/${vmid}/status/start`
        : `/nodes/${node}/lxc/${vmid}/status/start`;
      
      await this.makeRequest(endpoint);
      logger.info(`VM ${vmid} on node ${node} started`);
      
      // Clear cache
      await cacheService.del(`proxmox:vms:${node}`);
    } catch (error) {
      logger.error(`Failed to start VM ${vmid} on node ${node}:`, error);
      throw error;
    }
  }

  async stopVM(node: string, vmid: number, type: 'qemu' | 'lxc'): Promise<void> {
    try {
      const endpoint = type === 'qemu' 
        ? `/nodes/${node}/qemu/${vmid}/status/stop`
        : `/nodes/${node}/lxc/${vmid}/status/stop`;
      
      await this.makeRequest(endpoint);
      logger.info(`VM ${vmid} on node ${node} stopped`);
      
      // Clear cache
      await cacheService.del(`proxmox:vms:${node}`);
    } catch (error) {
      logger.error(`Failed to stop VM ${vmid} on node ${node}:`, error);
      throw error;
    }
  }

  isConfigured(): boolean {
    return this.api !== null;
  }
}

export const proxmoxService = new ProxmoxService();